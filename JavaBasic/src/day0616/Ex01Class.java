package day0616;
// 클래스
// 클래스란? 자바에서의 프로그램 하나 하나를 뜻한다.
// 우리가 지금껏 만들어왔던 클래스들은 사실
// 프로그램이 맞지만, 3세대 객체지향적 언어에서의 관점에서는
// 클래스라고 부를 수 없었다.
// 왜냐, 클래스는 반드시 데이터를 저장할 공간과 해당 클래스 변수들이
// 실행할 수 있는 기능이 같이 정의 되어 있어야 했지만
// 우리는 지금까지 둘 중 하나만 정의해왔기 때문이다.

// 프로그램을 기능의 집합이라고 생각했던 2세대 절차 지향적 언어와는 다르게
// 3세대 객체 지향적 언어에서는 프로그램을 더 작은 프로그램 변수들의 집합으로 본다.

// 즉 학생과 관련한 프로그램을 만들게 될 때,
// 우리는 기존에 학생 구조체를 따로 만들고, 기능도 따로 만들어주었지만
// 이제는 학생과 관련한 클래스를 만들어서 그 안에
// 해당 클래스 변수, 즉 객체가 어떠한 정보를 가질지 그리고 그 객체들이
// 실행시킬 메소드를 정의하고, 우리는 필요할 때마다 그 객체들을 만들어서 사용하게 된다.

// 클래스의 구성
// 클래스는 필드와 메소드로 이루어진다.
// 필드: 해당 클래스의 객체들이 가지고 있을 데이터들의 종류 *******  어떤 종류의 데이터를 저장할 수 있는지  *******
// 메소드: 해당 클래스의 객체들이 가지고 있을 실행 가능한 기능들

// static 키워드
// 스태틱 키워드는 객체지향적 프로그래밍에서는 사용을 기피해야하는 키워드이다.
// 왜냐하면, 스태틱 키워드가 붙으면 해당 메소드를
// 객체를 따로 생성하지 않고 메소드만 불러와서 사용을 하겠다 라는 의미가 되기 때문에
// 반드시 객체 생성을 거쳐야 하는 객체 지향적 관점에서는 스태틱 키워드는 사용을
// 피해야만 한다.

// 객체 vs 인스턴스
// 객체: 클레스 타입의 변수
// 인스턴스: 실체화가 끝난 클래스 타입의 변수 ----- 객체의 실체화, 실체화가 되어있는 객체

public class Ex01Class {
    // 클래스 안에 필드는 우리가 전에 만들었던 구조체와 똑같은 방식으로 선언한다.
    // 즉, 해당 클래스는  변수들이 어떤 데이터를 저장 가능한지를
    // 우리가 '선언'만 해주고, 실제 해당 데이터를 저장하는 것은
    // 그 객체를 사용하는 곳에서 해주면 된다.

    // 클래스 안에 메소드는
    // 해당 클래스 변수를 만들고 나서
    // 그 객체들이 공통적으로 실행시킬 수 있도록 만들어 주되
    // 앞서 설명했듯이 더 이상 static 키워드는 붙지 않는다.
    // ? static을 붙이면 어떤 영역 ? ?

    // 생성자(Constructor)
    // 생성자란, 객체를 생성할 때 실행시킬 코드를 모아둔 메소드이다.
    // 우리가 특별히 생성자를 따로 정의하지 않더라도
    // 자바가 기본적으로 제공해주는 기본 생성자가
    // 해당 객체의 필드를 초기화 시켜주는 역할을 한다.
    // 단, 이때에는 기본형 데이터 타입의 필드는 0으로,
    // 참조형 데이터타입의 필드는 null로 초기화해준다.

    // 생성자는 특이하게 리턴 타입이 아예 없고,
    // 메소드 이름은 ** 반드시 ** 클래스 이름과 일치해야 한다.

    // 필요에 따라서는 우리가 직접 생성자를 정의해줄 수도 있는데
    // 이때에는 한 가지 주의할 점이 파라미터 있는 생성자만 만들어주면,
    // 더 이상 파라미터 없는 생성자는 사용할 수 없다. 예시 ---> Scanner

    // 오버라이드(Override)
    // 오버라이드란? 부모 클래스로부터 상속받은 메소드를
    // 자식 클래스가 재정의하는 것을 '오버라이드'라고 한다.
    // 단, 오버라이드를 할 때 한 가지 주의할 점은
    // 해당 메소드를 선언할 때, 반드시 부모 클래스가 적은 것을 똑같이 적어야 한다는 점이다. (접근제어자, 리턴타입)


    // 호출 순위
    // 똑같은 개념끼리는 같은 이름을 사용할 수 없지만,
    // 필드와 메소드 변수는 서로 다른 개념이기 때문에
    // 같은 이름을 사용할 수 있는 대신,
    // 해당 메소드에서는 똑같은 이름이면 무조건
    // 변수를 뜻하게 된다.
    // 만약 필드와 메소드 변수가 같은 이름을 가졌을 때
    // 해당 변수에서 필드를 호출할 때에는
    // "이 메소드를 실행하는 객체"라는 뜻을 가진 this라는 키워드를 사용하게 된다.
    // 즉, 우리가 어떠한 파라미터로 값을 받아올 때
    // 필드와 파라미터의 이름이 같을 경우
    // "이 메소드를 실행시키는 객체"의 필드에 파라미터의 현재 값을 저장해라.
    // 를 적기 위해서는 this.필드 = 파라미터 로 적어야 한다.

    // 접근제한자(Access Modifider)
    // 접근제한자란 필드 혹은 메소드를 외부 클래스가
    // 접근을 할 수 있을지 말지를 지정하는 키워드
    // - public : 퍼블릭 접근제한자는 해당 메소드/필드를 다른 패키지의
    // 다른 클래스도 접근할 수 있게 한다.
    // - protected: 프로텍티드 접근제한자는 같은 패키지의 다른 클래스를 사용 가능하지만
    // 외부 패키지의 다른 클래스는 상속 관계가 아니면 접근할 수 없다.
    // - default : 디폴트 접근제한자는 같은 패키지의 다른 클래스들만 접근 가능하다.
    // 하지만 이미 default 라는 키워드는 switch문에서 사용하기 때문에
    // 우리는 아무런 접근 제한자를 적어주지 않으면 자동으로 디폴트 접근제한자가 걸린다.
    // 또한, 같은 패키지만 접근 가능하기 때문에 "패키지 접근제한자" 라고도 부르긴 하지만,
    // package 라는 키워드도 이미 사용중이므로 우리가 직접 쓰진 못한다.
    // private: 프라이빗 접근제한자는 해당 클래스 내부에서만 사용한다라는 의미로써
    // 다른 클래스면 같은 패키지이건 다른 패키지이건 접근할 수 없다.

    // 데이터 은닉화
    // 데이터 은닉화? 기본적으로 우리가 만드는 클래스의 객체
    // 안의 세부 내용을 외부에게 알리지 않고 다 숨기겠다 라는 의미이다.
    // 즉, 외부가 반드시 사용해야할 메소드 외에는 전부다 직접적인 접근을 막는 것이다.
    // 이렇게 직접적인 접근을 막고, 꼭 알아야할 메소드만 공개하는 것을
    // 우리가 캡슐화라고 한다.
    // 캡슐화의 가장 핵심은 접근을 막는 것이므로 당연히 우리가
    // 기존에서는 public 접근제한자만 사용했지만
    // 이제는 무조건 private 접근제한자를 사용하되
    // 외부가 사용해야할 메소드만 public 접근 제한자를 적용하면 된다.

    // getter(데이터 가져오기)/setter(데이터 세팅)
    // 겟터/셋터는 객체의 필드를 캡슐화하는 방법으로써,
    // 우리가 앞으로는 모든 필드에 private 접근 제한자를 적응시키면
    // 더 이상 외부 클래스가 직접적으로 해당 필드에 값을 저장하거나
    // 아니면 저장된 값을 호출할 수 없게 된다.
    // 대신, 겟터/셋터라는 메소드를 통해서 값을 저장하거나
    // 저장된 값을 호출하게 된다.

    // 겟터: 겟터는 필드의 현재 저장된 값을 불러오는 메소드이다.
    // 겟터는 다음과 같은 형식을 가진다.
    // public 필드타입 get필드이름() {
    //      return 필드이름; }

    // 셋터: 셋터는 해당 필드의 외부의 값을 저장하는 메소드이다.
    // 셋터는 다음과 같은 형식을 가진다.
    // public void set필드이름(필드와 동일한 파라미터) {
    //       this.필드 = 파라미터; }

    // 상속의 이유: 코드의 재사용성




}

























